const HomeMediator = artifacts.require('HomeMediator.sol')
const ForeignMediator = artifacts.require('ForeignMediator.sol')
const SimpleBridgeKitty = artifacts.require('SimpleBridgeKitty.sol')
const AMBMock = artifacts.require('AMBMock.sol')

const { ether, expectRevert, expectEvent, BN } = require('openzeppelin-test-helpers')
const { expect } = require('chai')
const { shouldBehaveLikeBasicMediator } = require('./basicMediator.test')

const maxGasPerTx = ether('1')
const tokenId = 1
const isReady = true
const cooldownIndex = 0
const nextActionAt = 2
const siringWithId = 3
const birthTime = 1511417999
const matronId = 4
const sireId = 5
const generation = 6
const genes = '623494533466173608148163391622294272936404886827521876326676079749575115'

contract('HomeMediator', accounts => {
  const owner = accounts[0]
  const user = accounts[1]
  beforeEach(async function() {
    this.bridge = await HomeMediator.new()
    this.mediatorContractOnOtherSide = ForeignMediator
  })
  shouldBehaveLikeBasicMediator(accounts)
  describe('transferToken', () => {
    it('should transfer token to mediator, burn the token and emit event on amb bridge ', async () => {
      // Given
      const contract = await HomeMediator.new()
      const bridgeContract = await AMBMock.new()
      await bridgeContract.setMaxGasPerTx(maxGasPerTx)
      const token = await SimpleBridgeKitty.new()
      const mediatorContractOnOtherSide = await ForeignMediator.new()

      await contract.initialize(
        bridgeContract.address,
        mediatorContractOnOtherSide.address,
        token.address,
        maxGasPerTx,
        owner
      )

      await token.mint(
        tokenId,
        isReady,
        cooldownIndex,
        nextActionAt,
        siringWithId,
        birthTime,
        matronId,
        sireId,
        generation,
        genes,
        user,
        { from: owner }
      )

      await token.transferOwnership(contract.address, { from: owner })

      // When
      // should approve the transfer first
      await expectRevert.unspecified(contract.transferToken(tokenId, { from: user }))

      await token.approve(contract.address, tokenId, { from: user })

      const { tx } = await contract.transferToken(tokenId, { from: user })

      // Then
      await expectEvent.inTransaction(tx, SimpleBridgeKitty, 'Transfer', {
        from: user,
        to: contract.address,
        tokenId: new BN(tokenId)
      })
      await expectEvent.inTransaction(tx, SimpleBridgeKitty, 'Death', {
        kittyId: new BN(tokenId)
      })
      await expectEvent.inTransaction(tx, AMBMock, 'MockedEvent')
    })
  })
  describe('handleBridgedTokens', () => {
    it('should mint with token Id and metadata', async () => {
      // Given
      const contract = await HomeMediator.new()
      const bridgeContract = await AMBMock.new()
      await bridgeContract.setMaxGasPerTx(maxGasPerTx)
      const token = await SimpleBridgeKitty.new()
      const mediatorContractOnOtherSide = await ForeignMediator.new()

      await contract.initialize(
        bridgeContract.address,
        mediatorContractOnOtherSide.address,
        token.address,
        maxGasPerTx,
        owner
      )

      await token.transferOwnership(contract.address, { from: owner })

      expect(await token.totalSupply()).to.be.bignumber.equal('0')

      const metadata =
        '0x' +
        '0000000000000000000000000000000000000000000000000000000000000001' + // isGestating
        '0000000000000000000000000000000000000000000000000000000000000001' + // isReady
        '0000000000000000000000000000000000000000000000000000000000000000' + // cooldownIndex
        '0000000000000000000000000000000000000000000000000000000000000002' + // nextActionAt
        '0000000000000000000000000000000000000000000000000000000000000003' + // siringWithId
        '000000000000000000000000000000000000000000000000000000005a16688f' + // birthTime
        '0000000000000000000000000000000000000000000000000000000000000004' + // matronId
        '0000000000000000000000000000000000000000000000000000000000000005' + // sireId
        '0000000000000000000000000000000000000000000000000000000000000006' + // generation
        '00005a56b294e64a52e421c928c63218845adac30406314c739c454bd2e731cb' // genes

      // When

      // must be called from bridge
      await expectRevert.unspecified(contract.handleBridgedTokens(user, tokenId, metadata, { from: user }))
      await expectRevert.unspecified(contract.handleBridgedTokens(user, tokenId, metadata, { from: owner }))

      const data = await contract.contract.methods.handleBridgedTokens(user, tokenId, metadata).encodeABI()

      const exampleTxHash = '0xf308b922ab9f8a7128d9d7bc9bce22cd88b2c05c8213f0e2d8104d78e0a9ecbb'
      const failedTxHash = '0x2ebc2ccc755acc8eaf9252e19573af708d644ab63a39619adb080a3500a4ff2e'

      // message must be generated by mediator contract on the other network
      await bridgeContract.executeMessageCall(contract.address, owner, data, failedTxHash, 1000000)
      expect(await bridgeContract.messageCallStatus(failedTxHash)).to.be.equal(false)

      const { tx } = await bridgeContract.executeMessageCall(
        contract.address,
        mediatorContractOnOtherSide.address,
        data,
        exampleTxHash,
        1000000
      )
      expect(await bridgeContract.messageCallStatus(exampleTxHash)).to.be.equal(true)

      // Then
      await expectEvent.inTransaction(tx, SimpleBridgeKitty, 'Birth', {
        owner: user,
        kittyId: new BN(tokenId),
        matronId: new BN(matronId),
        sireId: new BN(sireId),
        genes
      })
      expect(await token.totalSupply()).to.be.bignumber.equal('1')
      expect(await token.ownerOf(tokenId)).to.be.equal(user)
      const tokenList = await token.tokensOfOwner(user)
      expect(tokenList.length).to.be.equal(1)
      expect(tokenList[0]).to.be.bignumber.equal(new BN(tokenId))

      const mintedKitty = await token.getKitty(tokenId)

      expect(mintedKitty.isGestating).to.be.equal(true)
      expect(mintedKitty.isReady).to.be.equal(isReady)
      expect(mintedKitty.cooldownIndex).to.be.bignumber.equal(new BN(cooldownIndex))
      expect(mintedKitty.nextActionAt).to.be.bignumber.equal(new BN(nextActionAt))
      expect(mintedKitty.siringWithId).to.be.bignumber.equal(new BN(siringWithId))
      expect(mintedKitty.birthTime).to.be.bignumber.equal(new BN(birthTime))
      expect(mintedKitty.matronId).to.be.bignumber.equal(new BN(matronId))
      expect(mintedKitty.sireId).to.be.bignumber.equal(new BN(sireId))
      expect(mintedKitty.generation).to.be.bignumber.equal(new BN(generation))
      expect(mintedKitty.genes).to.be.bignumber.equal(new BN(genes))
    })
  })
})
